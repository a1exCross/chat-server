// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/a1exCross/chat-server/internal/service.ChatServive -o chat_servive.go -n ChatServiveMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/a1exCross/chat-server/internal/model"
	"github.com/gojuno/minimock/v3"
)

// ChatServiveMock implements service.ChatServive
type ChatServiveMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, c2 model.ChatDTO) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, c2 model.ChatDTO)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mChatServiveMockCreate

	funcDelete          func(ctx context.Context, i1 int64) (err error)
	inspectFuncDelete   func(ctx context.Context, i1 int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mChatServiveMockDelete
}

// NewChatServiveMock returns a mock for service.ChatServive
func NewChatServiveMock(t minimock.Tester) *ChatServiveMock {
	m := &ChatServiveMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mChatServiveMockCreate{mock: m}
	m.CreateMock.callArgs = []*ChatServiveMockCreateParams{}

	m.DeleteMock = mChatServiveMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ChatServiveMockDeleteParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServiveMockCreate struct {
	mock               *ChatServiveMock
	defaultExpectation *ChatServiveMockCreateExpectation
	expectations       []*ChatServiveMockCreateExpectation

	callArgs []*ChatServiveMockCreateParams
	mutex    sync.RWMutex
}

// ChatServiveMockCreateExpectation specifies expectation struct of the ChatServive.Create
type ChatServiveMockCreateExpectation struct {
	mock    *ChatServiveMock
	params  *ChatServiveMockCreateParams
	results *ChatServiveMockCreateResults
	Counter uint64
}

// ChatServiveMockCreateParams contains parameters of the ChatServive.Create
type ChatServiveMockCreateParams struct {
	ctx context.Context
	c2  model.ChatDTO
}

// ChatServiveMockCreateResults contains results of the ChatServive.Create
type ChatServiveMockCreateResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for ChatServive.Create
func (mmCreate *mChatServiveMockCreate) Expect(ctx context.Context, c2 model.ChatDTO) *mChatServiveMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiveMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiveMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &ChatServiveMockCreateParams{ctx, c2}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the ChatServive.Create
func (mmCreate *mChatServiveMockCreate) Inspect(f func(ctx context.Context, c2 model.ChatDTO)) *mChatServiveMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ChatServiveMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by ChatServive.Create
func (mmCreate *mChatServiveMockCreate) Return(i1 int64, err error) *ChatServiveMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiveMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiveMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ChatServiveMockCreateResults{i1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the ChatServive.Create method
func (mmCreate *mChatServiveMockCreate) Set(f func(ctx context.Context, c2 model.ChatDTO) (i1 int64, err error)) *ChatServiveMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the ChatServive.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the ChatServive.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the ChatServive.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mChatServiveMockCreate) When(ctx context.Context, c2 model.ChatDTO) *ChatServiveMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiveMock.Create mock is already set by Set")
	}

	expectation := &ChatServiveMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &ChatServiveMockCreateParams{ctx, c2},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up ChatServive.Create return parameters for the expectation previously defined by the When method
func (e *ChatServiveMockCreateExpectation) Then(i1 int64, err error) *ChatServiveMock {
	e.results = &ChatServiveMockCreateResults{i1, err}
	return e.mock
}

// Create implements service.ChatServive
func (mmCreate *ChatServiveMock) Create(ctx context.Context, c2 model.ChatDTO) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, c2)
	}

	mm_params := ChatServiveMockCreateParams{ctx, c2}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := ChatServiveMockCreateParams{ctx, c2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ChatServiveMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ChatServiveMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, c2)
	}
	mmCreate.t.Fatalf("Unexpected call to ChatServiveMock.Create. %v %v", ctx, c2)
	return
}

// CreateAfterCounter returns a count of finished ChatServiveMock.Create invocations
func (mmCreate *ChatServiveMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ChatServiveMock.Create invocations
func (mmCreate *ChatServiveMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ChatServiveMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mChatServiveMockCreate) Calls() []*ChatServiveMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ChatServiveMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ChatServiveMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *ChatServiveMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiveMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiveMock.Create")
		} else {
			m.t.Errorf("Expected call to ChatServiveMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to ChatServiveMock.Create")
	}
}

type mChatServiveMockDelete struct {
	mock               *ChatServiveMock
	defaultExpectation *ChatServiveMockDeleteExpectation
	expectations       []*ChatServiveMockDeleteExpectation

	callArgs []*ChatServiveMockDeleteParams
	mutex    sync.RWMutex
}

// ChatServiveMockDeleteExpectation specifies expectation struct of the ChatServive.Delete
type ChatServiveMockDeleteExpectation struct {
	mock    *ChatServiveMock
	params  *ChatServiveMockDeleteParams
	results *ChatServiveMockDeleteResults
	Counter uint64
}

// ChatServiveMockDeleteParams contains parameters of the ChatServive.Delete
type ChatServiveMockDeleteParams struct {
	ctx context.Context
	i1  int64
}

// ChatServiveMockDeleteResults contains results of the ChatServive.Delete
type ChatServiveMockDeleteResults struct {
	err error
}

// Expect sets up expected params for ChatServive.Delete
func (mmDelete *mChatServiveMockDelete) Expect(ctx context.Context, i1 int64) *mChatServiveMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiveMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatServiveMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &ChatServiveMockDeleteParams{ctx, i1}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the ChatServive.Delete
func (mmDelete *mChatServiveMockDelete) Inspect(f func(ctx context.Context, i1 int64)) *mChatServiveMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ChatServiveMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by ChatServive.Delete
func (mmDelete *mChatServiveMockDelete) Return(err error) *ChatServiveMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiveMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatServiveMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ChatServiveMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the ChatServive.Delete method
func (mmDelete *mChatServiveMockDelete) Set(f func(ctx context.Context, i1 int64) (err error)) *ChatServiveMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the ChatServive.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the ChatServive.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the ChatServive.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mChatServiveMockDelete) When(ctx context.Context, i1 int64) *ChatServiveMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiveMock.Delete mock is already set by Set")
	}

	expectation := &ChatServiveMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &ChatServiveMockDeleteParams{ctx, i1},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up ChatServive.Delete return parameters for the expectation previously defined by the When method
func (e *ChatServiveMockDeleteExpectation) Then(err error) *ChatServiveMock {
	e.results = &ChatServiveMockDeleteResults{err}
	return e.mock
}

// Delete implements service.ChatServive
func (mmDelete *ChatServiveMock) Delete(ctx context.Context, i1 int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, i1)
	}

	mm_params := ChatServiveMockDeleteParams{ctx, i1}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := ChatServiveMockDeleteParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ChatServiveMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ChatServiveMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, i1)
	}
	mmDelete.t.Fatalf("Unexpected call to ChatServiveMock.Delete. %v %v", ctx, i1)
	return
}

// DeleteAfterCounter returns a count of finished ChatServiveMock.Delete invocations
func (mmDelete *ChatServiveMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ChatServiveMock.Delete invocations
func (mmDelete *ChatServiveMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ChatServiveMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mChatServiveMockDelete) Calls() []*ChatServiveMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ChatServiveMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ChatServiveMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ChatServiveMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiveMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiveMock.Delete")
		} else {
			m.t.Errorf("Expected call to ChatServiveMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to ChatServiveMock.Delete")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServiveMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServiveMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServiveMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone()
}
